<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√âchecs Multijoueur</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            width: 100%;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .chess-board-container {
            padding: 20px;
            flex: 1;
        }

        .game-info {
            background: #f8f9fa;
            padding: 20px;
            width: 300px;
            border-left: 1px solid #dee2e6;
        }

        .chess-board {
            width: 400px;
            height: 400px;
            margin: 0 auto;
            border: 3px solid #8b4513;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
        }

        .square {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #ffff99 !important;
            box-shadow: inset 0 0 0 3px #ff6b6b;
        }

        .square.highlight {
            background-color: #90EE90 !important;
        }

        .square.last-move {
            background-color: #ffeb3b !important;
        }

        .square:hover {
            opacity: 0.8;
        }

        .game-status {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }

        .game-status h2 {
            color: #1976d2;
            margin-bottom: 5px;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            gap: 10px;
        }

        .player {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .player.white {
            background: #fff;
            border: 2px solid #ddd;
        }

        .player.black {
            background: #333;
            color: white;
            border: 2px solid #555;
        }

        .player.active {
            border-color: #4caf50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }

        .move-history {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            background: white;
        }

        .move-history h3 {
            margin-bottom: 10px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .move-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .move-item:last-child {
            border-bottom: none;
        }

        .move-number {
            font-weight: bold;
            color: #666;
        }

        .move-notation {
            font-family: monospace;
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .join-form {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 400px;
        }

        .join-form h1 {
            margin-bottom: 20px;
            color: #333;
        }

        .join-form input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
        }

        .join-form input:focus {
            outline: none;
            border-color: #007bff;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
            }
            
            .game-info {
                width: 100%;
                border-left: none;
                border-top: 1px solid #dee2e6;
            }
            
            .chess-board {
                width: 320px;
                height: 320px;
            }
            
            .square {
                width: 40px;
                height: 40px;
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <!-- Formulaire de connexion -->
    <div id="joinForm" class="join-form">
        <h1>üèÅ √âchecs Multijoueur</h1>
        <input type="text" id="playerName" placeholder="Votre nom" maxlength="20">
        <input type="text" id="gameId" placeholder="ID de la partie (ou laissez vide)" maxlength="10">
        <button class="btn btn-primary" onclick="joinGame()">Rejoindre la partie</button>
    </div>

    <!-- Interface de jeu -->
    <div id="gameInterface" class="game-container hidden">
        <div class="chess-board-container">
            <div class="game-status" id="gameStatus">
                <h2>En attente d'un adversaire...</h2>
                <p>Partagez l'ID de partie : <strong id="currentGameId"></strong></p>
            </div>
            
            <div class="player-info">
                <div class="player white" id="whitePlayer">
                    <strong>Blancs</strong>
                    <div id="whitePlayerName">En attente...</div>
                </div>
                <div class="player black" id="blackPlayer">
                    <strong>Noirs</strong>
                    <div id="blackPlayerName">En attente...</div>
                </div>
            </div>

            <div class="chess-board" id="chessBoard"></div>
        </div>

        <div class="game-info">
            <div class="move-history">
                <h3>üìú Historique des coups</h3>
                <div id="moveHistoryList"></div>
            </div>

            <div class="controls">
                <button class="btn btn-primary" onclick="newGame()">Nouvelle partie</button>
                <button class="btn btn-secondary" onclick="copyGameLink()">Copier lien</button>
                <button class="btn btn-secondary" onclick="leaveGame()">Quitter</button>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Variables globales
        let socket;
        let gameId;
        let playerColor;
        let selectedSquare = null;
        let currentGameState = null;
        let moveHistory = [];
        let isReconnecting = false;

        // Pi√®ces d'√©checs Unicode
        const pieces = {
            'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
            'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
        };

        // Initialiser la connexion
        function initSocket() {
            socket = io();

            // Syst√®me de ping pour maintenir la connexion
            setInterval(() => {
                if (socket.connected) {
                    socket.emit('ping');
                }
            }, 25000); // Ping toutes les 25 secondes

            socket.on('pong', () => {
                console.log('üèì Connexion active');
            });

            socket.on('connect', () => {
                console.log('üîå Connect√© au serveur');
            });

            socket.on('disconnect', (reason) => {
                console.log('‚ùå D√©connect√©:', reason);
                updateGameStatus('‚ö†Ô∏è Connexion perdue... Reconnexion...');
            });

            socket.on('reconnect', () => {
                console.log('üîÑ Reconnect√© au serveur');
                // Rejoindre automatiquement la partie
                if (gameId && localStorage.getItem('chess_playerName')) {
                    socket.emit('join-game', { 
                        gameId, 
                        playerName: localStorage.getItem('chess_playerName')
                    });
                }
            });

            socket.on('player-assigned', (data) => {
                playerColor = data.color;
                currentGameState = data.gameState;
                createBoard(); // Cr√©er l'√©chiquier avec la bonne orientation
                updateBoard();
                updateGameStatus(`Vous jouez les ${playerColor === 'white' ? 'Blancs' : 'Noirs'}`);
            });

            socket.on('game-start', (data) => {
                document.getElementById('whitePlayerName').textContent = data.white;
                document.getElementById('blackPlayerName').textContent = data.black;
                currentGameState = data.gameState;
                if (!document.getElementById('chessBoard').hasChildNodes()) {
                    createBoard(); // Cr√©er l'√©chiquier si pas encore fait
                }
                updateBoard();
                updateGameStatus('La partie commence !');
                updatePlayerTurn();
            });

            socket.on('move-made', (data) => {
                console.log('üì® Coup re√ßu du serveur:', data.move.san);
                
                // Mettre √† jour avec l'√©tat officiel du serveur
                currentGameState = data.gameState;
                moveHistory = data.moveHistory;
                
                updateBoard(); // Mise √† jour avec l'√©tat r√©el
                updateMoveHistory();
                updatePlayerTurn();
                clearSelection();
                
                console.log('‚úÖ Interface mise √† jour c√¥t√©', playerColor);
            });

            socket.on('move-history', (data) => {
                moveHistory = data;
                updateMoveHistory();
            });

            socket.on('game-over', (data) => {
                updateGameStatus(`üèÅ ${data.result}`);
                clearSelection();
            });

            socket.on('invalid-move', (message) => {
                console.log('‚ùå Coup invalide:', message);
                
                // Restaurer l'√©chiquier √† l'√©tat correct
                updateBoard();
                clearSelection();
                
                alert(message);
            });

            socket.on('player-disconnected', () => {
                updateGameStatus('‚ö†Ô∏è Un joueur s\'est d√©connect√©');
            });

            socket.on('spectator-mode', (data) => {
                currentGameState = data.gameState;
                moveHistory = data.moveHistory;
                updateBoard();
                updateMoveHistory();
                updateGameStatus('üëÄ Mode spectateur');
                if (data.players.white) {
                    document.getElementById('whitePlayerName').textContent = data.players.white;
                }
                if (data.players.black) {
                    document.getElementById('blackPlayerName').textContent = data.players.black;
                }
            });

            socket.on('game-reset', (data) => {
                currentGameState = data.gameState;
                moveHistory = data.moveHistory;
                updateBoard();
                updateMoveHistory();
                updateGameStatus('Nouvelle partie commenc√©e !');
                clearSelection();
            });
        }

        // Rejoindre une partie
        function joinGame() {
            const playerName = document.getElementById('playerName').value.trim();
            if (!playerName) {
                alert('Veuillez entrer votre nom');
                return;
            }

            gameId = document.getElementById('gameId').value.trim() || generateGameId();
            document.getElementById('currentGameId').textContent = gameId;

            // Sauvegarder dans localStorage pour la reconnexion
            localStorage.setItem('chess_gameId', gameId);
            localStorage.setItem('chess_playerName', playerName);

            initSocket();
            socket.emit('join-game', { gameId, playerName });

            document.getElementById('joinForm').classList.add('hidden');
            document.getElementById('gameInterface').classList.remove('hidden');
        }

        // G√©n√©rer un ID de partie al√©atoire
        function generateGameId() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }

        // Cr√©er l'√©chiquier (avec orientation selon la couleur)
        function createBoard() {
            const board = document.getElementById('chessBoard');
            board.innerHTML = '';

            // Orientation selon la couleur du joueur
            const isBlackPlayer = playerColor === 'black';
            
            for (let rank = (isBlackPlayer ? 1 : 8); isBlackPlayer ? rank <= 8 : rank >= 1; isBlackPlayer ? rank++ : rank--) {
                for (let file = (isBlackPlayer ? 7 : 0); isBlackPlayer ? file >= 0 : file < 8; isBlackPlayer ? file-- : file++) {
                    const square = document.createElement('div');
                    const squareId = String.fromCharCode(97 + file) + rank;
                    
                    square.id = squareId;
                    square.className = `square ${(rank + file) % 2 === 0 ? 'dark' : 'light'}`;
                    square.addEventListener('click', () => handleSquareClick(squareId));
                    
                    board.appendChild(square);
                }
            }
            updateBoard();
        }

        // Mettre √† jour l'√©chiquier
        function updateBoard() {
            if (!currentGameState) {
                console.log('‚ö†Ô∏è Pas d\'√©tat de jeu disponible');
                return;
            }

            const board = fenToBoard(currentGameState);
            
            for (let rank = 8; rank >= 1; rank--) {
                for (let file = 0; file < 8; file++) {
                    const squareId = String.fromCharCode(97 + file) + rank;
                    const square = document.getElementById(squareId);
                    if (!square) continue;
                    
                    const piece = board[8 - rank][file];
                    
                    // Mettre √† jour le contenu de la case
                    square.textContent = piece ? pieces[piece] : '';
                    
                    // R√©initialiser les classes
                    square.className = `square ${(rank + file) % 2 === 0 ? 'dark' : 'light'}`;
                    
                    // Marquer le dernier coup
                    if (moveHistory.length > 0) {
                        const lastMove = moveHistory[moveHistory.length - 1];
                        if (squareId === lastMove.from || squareId === lastMove.to) {
                            square.classList.add('last-move');
                        }
                    }
                }
            }
        }

        // Convertir FEN en tableau 2D
        function fenToBoard(fen) {
            const position = fen.split(' ')[0];
            const ranks = position.split('/');
            const board = [];

            for (const rank of ranks) {
                const row = [];
                for (const char of rank) {
                    if (isNaN(char)) {
                        row.push(char);
                    } else {
                        for (let i = 0; i < parseInt(char); i++) {
                            row.push(null);
                        }
                    }
                }
                board.push(row);
            }
            return board;
        }

        // G√©rer les clics sur l'√©chiquier
        function handleSquareClick(squareId) {
            if (!selectedSquare) {
                // S√©lectionner une case
                const square = document.getElementById(squareId);
                if (square.textContent) {
                    selectedSquare = squareId;
                    square.classList.add('selected');
                    highlightPossibleMoves(squareId);
                }
            } else {
                // Tenter un coup
                if (selectedSquare !== squareId) {
                    makeMove(selectedSquare, squareId);
                }
                clearSelection();
            }
        }

        // Effacer la s√©lection
        function clearSelection() {
            if (selectedSquare) {
                const square = document.getElementById(selectedSquare);
                square.classList.remove('selected');
                selectedSquare = null;
            }
            
            // Supprimer tous les surbrillances
            document.querySelectorAll('.square.highlight').forEach(sq => {
                sq.classList.remove('highlight');
            });
        }

        // Surligner les coups possibles (am√©lioration)
        function highlightPossibleMoves(from) {
            // Ne pas surligner toutes les cases, seulement la case s√©lectionn√©e
            // Cette fonction sera am√©lior√©e plus tard avec la vraie logique des √©checs
            console.log('Pi√®ce s√©lectionn√©e:', from);
        }

        // Effectuer un coup
        function makeMove(from, to) {
            console.log('üéØ Tentative de coup:', from, 'vers', to);
            
            // Mise √† jour imm√©diate c√¥t√© client (optimiste)
            updateBoardOptimistic(from, to);
            
            socket.emit('make-move', {
                gameId: gameId,
                move: { from, to }
            });
        }
        
        // Mise √† jour optimiste (avant confirmation serveur)
        function updateBoardOptimistic(from, to) {
            const fromSquare = document.getElementById(from);
            const toSquare = document.getElementById(to);
            
            if (fromSquare && toSquare) {
                // D√©placer visuellement la pi√®ce
                toSquare.textContent = fromSquare.textContent;
                fromSquare.textContent = '';
                
                // Marquer le coup
                document.querySelectorAll('.last-move').forEach(sq => sq.classList.remove('last-move'));
                fromSquare.classList.add('last-move');
                toSquare.classList.add('last-move');
            }
        }

        // Mettre √† jour l'historique des coups
        function updateMoveHistory() {
            const historyList = document.getElementById('moveHistoryList');
            historyList.innerHTML = '';

            for (let i = 0; i < moveHistory.length; i++) {
                const move = moveHistory[i];
                const moveItem = document.createElement('div');
                moveItem.className = 'move-item';
                
                const moveNumber = Math.floor(i / 2) + 1;
                const isWhiteMove = i % 2 === 0;
                
                moveItem.innerHTML = `
                    <span class="move-number">${moveNumber}${isWhiteMove ? '.' : '...'}</span>
                    <span class="move-notation">${move.move}</span>
                `;
                
                historyList.appendChild(moveItem);
            }

            // Faire d√©filer vers le bas
            historyList.scrollTop = historyList.scrollHeight;
        }

        // Mettre √† jour le statut du jeu
        function updateGameStatus(message) {
            document.getElementById('gameStatus').innerHTML = `<h2>${message}</h2>`;
        }

        // Mettre √† jour le tour du joueur
        function updatePlayerTurn() {
            const fen = currentGameState;
            const turn = fen.split(' ')[1]; // 'w' ou 'b'
            
            const whitePlayer = document.getElementById('whitePlayer');
            const blackPlayer = document.getElementById('blackPlayer');
            
            whitePlayer.classList.remove('active');
            blackPlayer.classList.remove('active');
            
            if (turn === 'w') {
                whitePlayer.classList.add('active');
                updateGameStatus('Au tour des Blancs');
            } else {
                blackPlayer.classList.add('active');
                updateGameStatus('Au tour des Noirs');
            }
        }

        // Nouvelle partie
        function newGame() {
            if (confirm('√ätes-vous s√ªr de vouloir commencer une nouvelle partie ?')) {
                socket.emit('new-game', gameId);
            }
        }

        // Copier le lien de la partie
        function copyGameLink() {
            const link = `${window.location.origin}/game/${gameId}`;
            navigator.clipboard.writeText(link).then(() => {
                alert('Lien copi√© dans le presse-papiers !');
            });
        }

        // Quitter la partie
        function leaveGame() {
            if (confirm('√ätes-vous s√ªr de vouloir quitter la partie ?')) {
                location.reload();
            }
        }

        // G√©rer les param√®tres d'URL et reconnexion automatique
        window.addEventListener('load', () => {
            const urlPath = window.location.pathname;
            const match = urlPath.match(/\/game\/(.+)/);
            if (match) {
                document.getElementById('gameId').value = match[1];
            }

            // Reconnexion automatique
            const savedGameId = localStorage.getItem('chess_gameId');
            const savedPlayerName = localStorage.getItem('chess_playerName');
            
            if (savedGameId && savedPlayerName) {
                document.getElementById('gameId').value = savedGameId;
                document.getElementById('playerName').value = savedPlayerName;
                
                // Proposer la reconnexion
                if (confirm(`Reconnecter √† la partie ${savedGameId} en tant que ${savedPlayerName} ?`)) {
                    isReconnecting = true;
                    joinGame();
                }
            }
        });
    </script>
</body>
</html>